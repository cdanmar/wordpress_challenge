# WordPress on GKE

## Infrastructure Proposal

### Cluster Requirements

#### Zones
If latency is critical for this scenario, I propose two clusters be created: one in `asia-northeast1` and `us-west2`.

Due to the usage patterns stated here, (low rate of change, low rate database queries), I believe we can deploy changes to both clusters with relatively low complexity.

#### Autoscaling

Node Autoscaling should be enabled in this cluster. This makes HPA (Horizontal Pod Autoscaling) easier to implement in later steps.

#### Service Accounts

Service Accounts should be provisioned for this cluster in order for services to be able to authenticate and write out logs to the Log Warehouse.

#### Hosted MariaDB

I would use a hosted MariaDB instance in order to avoid statefulness in the cluster, therefore reducing complexity.

### GKE Configuration

#### Ingress Controller

For the ingress controller, I would use NGINX  as it plays well for other tools I plan to use with this stack. For the installation, I would use the NGINX helm chart, allowing it to provision a public IP for me to use in later steps.

##### Note! Because we are deploying two clusters, I would leverage Cloud CDN to route users to the proper cluster

#### Cert Manager

In order to automate cluster certificates, I would install Cert Manager on both clusters. I would then create a certificate issuer in one cluster, exporting the generated cert to the second cluster.

#### Namespace

A Wordpress namespace needs to be created in order to deploy any serves to it. We do not want to deploy any resources to the default namespace.

#### Ingress

An ingress will need to be deployed to the Wordpress namespace. Here is a code snippet of what that may look like:

```yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: cheese
  namespace: wordpress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - blog.cdanmar.com
    secretName: blog-tls
  rules:
  - host: blog.cdanmar.com
    http:
      paths:
      - path: /
        backend:
          serviceName: wordpress
          servicePort: http
```

Where the TLS values are those generated by cert manager, and the actual name of the service is that which is generated by the helm chart. We are now ready to deploy WordPress

### WordPress Installation

#### A word on developer workflows

There are many ways to build and maintain a release of WordPress in Kubernetes. Due to the static/immutable nature of this scenario, it makes sense for developers to make/test changes locally using Docker Containers. The would then push their changes out to version control, eventually building a Docker Image that we get to use as part of a release.

#### Cloud Build for CI/CD

In order to trigger a release of Wordpress, we would create a Cloud Build pipeline that would build from the application source. This pipeline would be triggered by developers when pushing to a branch they specify.

This pipeline would then push the built image to the GCP Container Registry.

#### Wordpress Service

For the Wordpress Service Manifest, we will need to create a service of type "LoadBalancer" in order to handle the anticipated peak load. This service would live in the Wordpress Namespace

#### Wordpress Deployment

We will need a Deployment with a reference to the image we built in earlier steps. The deployment should contain a replica set with a minimum set of 3 pods.

The deployment should have health checks to enable Liveliness/Readiness Checks

#### Horizontal Pod Autoscaling Manifest

Horizontal Pod Autoscaling would allow us to scale up the number of pods based on cluster metrics (such as memory usage) or custom metrics fed to the metrics server (such as connections per second)

Combined with Cluster Autoscaling, this allows us to scale horizontally to meet demand during peak hours.

#### Prometheus StackDriver Exporter

As part of this deployment, I would enable a prometheus exporter, and point it to export logs to stackdriver and the Log Warehouse. This can be done as a sidecar or perhaps a DaemonSet.
